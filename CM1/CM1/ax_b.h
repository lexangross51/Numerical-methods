#pragma once

typedef double real;

// Решение СЛАУ с нижнетреугольной матрицей. Ищем вектор y
real* y(real* ia, real* di, real* l, real* b, size_t n)
{
    real* y = new real[n];
    real sum = 0.0;
    // Проходим по всем строкам
    for (size_t i = 0; i < n; i++)
    {
        y[i] = 0.0;
        // Считаем количество элементов в строке
        size_t prof = ia[i + 1] - ia[i];
        // Если элементы есть
        if (prof > 0)
        {
            // то определяем, с какого столбца 
            // начинаются элементы
            size_t j = i - prof;

            sum = 0.0;
            // Выполняем цикл столько раз, сколько
            // элементов в строке
            for (size_t k = 0; k < prof; k++)
            {
                // Находим нужные элементы и 
                // накпливаем их произведение 
                // в сумму
                size_t indl = ia[i] + k - 1;
                sum += l[indl] * y[j + k];
            }
        }
        // Считаем y[i] по формуле
        y[i] = (b[i] - sum) / di[i];
    }
    return y;
}

// Решение СЛАУ с верхнетреугольной матрицей. Ищем вектор x
void x_solve(real* ia, real* u, real* y, real*& x, size_t n)
{
    x = new real[n];

    // По формуле для нахождения x[i] нужно вычитать 
    // накопленную сумму из y[i], поэтому сразу 
    // инициализируем x соответствующим y
    for (size_t j = 0; j < n; j++)
        x[j] = y[j];

    // Проходим по всем столбцам, начиная с последнего
    for (int j = n - 1; j >= 0; j--)
    {
        // Определяем количество элементов в столбце
        size_t prof = ia[j + 1] - ia[j];
        // Если они есть, то
        if (prof > 0)
        {
            // определяем, с какой строки начинаются
            // элементы
            size_t i = j - prof;
            // Выполняем цикл столько раз, сколько 
            // элементов в столбце
            for (size_t k = 0; k < prof; k++)
            {
                // Вычитаем из каждого x, начиная с 
                // первого и до последнего(не включая)
                // произведение текущего элемента 
                // верхнетреугольной матрицы на последний
                // посчитанный x
                size_t indu = ia[j] + k - 1;
                real p = u[indu] * x[j];
                x[i + k] -= p;
            }
        }
    }
}