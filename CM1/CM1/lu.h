#pragma once
#include <utility>
#include <fstream>

typedef double real;

// Функция LU разложения профильной матрицы
void LU(size_t n, real* ia, real* di, real* al, real* au)
{
    // Проходим по всем строкам
    for (size_t i = 1; i < n; i++)
    {
        // Накапливаемая сумма для вычета из диагоального элемента
        real sumdi = 0.0;
        // Столбец, с которого начинаются ненулевые элементы
        size_t j0 = i - (ia[i + 1] - ia[i]);

        // Выполняем цикл столько раз, сколько ненулевых элементов в строке.
        // Начинаеи идти с первого ненулевого элемента
        for (size_t ii = ia[i] - 1; ii < ia[i + 1] - 1; ii++)
        {
            // Определяем номер текущего столбца 
            size_t j = ii + 1 - ia[i] + j0;
            // jbeg - jend => показывает количество элементов в j-ом столбце
            size_t jbeg = ia[j];
            size_t jend = ia[j + 1];

            // Если в столбце есть элементы
            if (jbeg < jend)
            {
                // То определяем, с какой строки они начинаются
                size_t i0 = j - (jend - jbeg);
                // Берем максимальное из значений - либо начальный столбец, 
                // либо начальная строка. Берем минимальное значение - либо 
                // текущий столбец, либо предыдущая строка. Делаем это для того, 
                // чтобы гарантированно пройти по всем элементам либо строки 
                // нижнего треугольника, либо столбца верхнего, чтобы вычислить  
                // сумму элементов, которая будет вычитаться из высчитываемого 
                // на данной итерации элемента(см.формулы)
                size_t jjbeg = std::max(j0, i0);
                size_t jjend = std::min(j, i - 1);

                // Считаем текущий элемент нижнего треугольника
                real cl = 0.0;
                for (size_t k = 0; k < jjend - jjbeg; k++)
                {
                    size_t indau = ia[j] - 1 + jjbeg - i0 + k;
                    size_t indal = ia[i] - 1 + jjbeg - j0 + k;
                    cl += au[indau] * al[indal];
                }
                al[ii] -= cl;

                // Считаем текущий элемент верхнего треугольника
                real cu = 0.0;
                for (size_t k = 0; k < jjend - jjbeg; k++)
                {
                    size_t indal = ia[j] - 1 + jjbeg - i0 + k;
                    size_t indau = ia[i] - 1 + jjbeg - j0 + k;
                    cu += au[indau] * al[indal];
                }
                au[ii] -= cu;
            }
            // Для того, чтобы до конца вычислить элемент верхнего треугольника, 
            // необходимо разделить его на диагональный элемент, который находится 
            // в той же строке, что и сам высчитываемый элемент
            au[ii] /= di[j];

            // Считаем частичную сумму, которая будет вычитаться из диагонального 
            // элемента после прохода по всей строке
            sumdi += al[ii] * au[ii];
        }
        // Пересчитываем диагональный элемент текущей строки
        di[i] -= sumdi;
    }
}